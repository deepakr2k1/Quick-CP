{
    "default": {
        "prefix": [
            "inc",
            "include",
            "default"
        ],
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define FastIO           ios_base::sync_with_stdio(false),cin.tie(NULL);",
            "#define dbg              cout<<\"-------------------------\\n\" ",
            "#define endl             \"\\n\"",
            "#define rep(i,a,b)       for(int i=a;i<=b;i++)",
            "#define irep(i,a,b)      for(int i=a;i>=b;i--)",
            "#define ip(V,n)          vector<int> V(n); for(int _i=0;_i<n;_i++) cin>>V[_i]",
            "#define op(V,sep)        for(int _i=0;_i<V.size();_i++) cout<<V[_i]<<sep;cout<<endl",
            "#define all(x)           (x).begin(),(x).end()",
            "#define vi               vector<int>",
            "#define vvi              vector<vector<int>>",
            "#define pb               push_back",
            "#define pii              pair<int,int>",
            "#define mp               make_pair",
            "#define fi               first",
            "#define se               second",
            "#define int              long long int",
            "#define INF              1e18",
            "#define op2(V,sep)        for(int _i=0;_i<V.size();_i++) {for(int _j=0;_j<V[_i].size();_j++) cout<<V[_i][_j]<<sep; cout<<endl;}",
            "inline void readInt(int &x) {",
            "\tbool neg = false;",
            "\tregister int c;",
            "\tx = 0;",
            "\tc=getchar();",
            "\tif(c=='-') neg = true, c=getchar();",
            "\tfor(;(c>47 && c<58);c=getchar()) x = (x<<1) + (x<<3) +c -48;",
            "\tif(neg) x = -x;",
            "}",
            "// ....................  zero_bug  ....................",
            "",
            "void solve() {",
            "}",
            "",
            "int32_t main() {",
            "\tFastIO",
            "\t#ifdef NCR",
            "\t\tpreCompute();",
            "\t#endif  // Power | ModInverse | Factorial | NCRmodP",
            "\t#ifdef SIEVE",
            "\t\tsieve();",
            "\t#endif  // checkPrime(sieve) | getFactorization",
            "\tint t;",
            "\tcin>>t;",
            "\trep(tt,1,t) {",
            "\t\t// cout<<\"Case #\"<<tt<<\":\"<<\" \";",
            "\t\tsolve();",
            "\t}",
            "}",
        ],
    },
    "NCR": {
        "prefix": [
            "factorial",
            "modinverse",
            "power",
            "ncr",
        ],
        "body": [
            "#define NCR",
            "#define MAX 200005",
            "#define MOD 1000000007",
            "",
            "int Fac[MAX];",
            "int InFac[MAX];",
            "",
            "int power(int x,int y)                      // Iterative Function to calculate (x^y)%MOD in O(logy)",
            "{",
            "\tint res=1;",
            "\tx=x%MOD;",
            "\twhile (y>0) {",
            "\t\tif(y&1) res=(res*x)%MOD;",
            "\t\ty=y>>1;",
            "\t\tx=(x*x)%MOD;",
            "\t}",
            "\treturn res;",
            "}",
            "",
            "int modInverse(int n) {                     // Returns n^(-1) % MOD",
            "\treturn power(n,MOD-2);",
            "}",
            "",
            "void preCompute() {                         // pre-compute the factorial and factorial-inverse of 0...2*10^5 in O(MAX)",
            "\tFac[0]=1;",
            "\tfor (int i=1;i<MAX;i++)",
            "\t\tFac[i]=(Fac[i-1]*i)%MOD;",
            "\tfor(int i=0;i<MAX;i++)",
            "\t\tInFac[i]=modInverse(Fac[i]);",
            "}",
            "",
            "int nCrModPFermat(int n,int r)              // nCr % MOD using Fermat's little theorem in O(1)",
            "{",
            "\tif(n<r)",
            "\t\treturn 0;",
            "\tif(r==0)",
            "\t\treturn 1;",
            "\treturn ((Fac[n] * InFac[r])%MOD * InFac[n-r])%MOD;",
            "}",
            "",
        ],
    },
    "Sieve": {
        "prefix": [
            "prime",
            "sieve",
            "getFactorization",
        ],
        "body": [
            "#define SIEVE",
            "#define MAX 200005",
            "int spf[MAX];                           // stores smallest prime factor for every number (spf[prime_no.]=prime_no.)",
            "",
            "void sieve()                            // O(nloglogn) ",
            "{ ",
            "\tfor(int i=1;i<MAX;i++)",
            "\t\tspf[i]=i;",
            "\tfor(int i=4;i<MAX;i+=2)",
            "\t\tspf[i]=2;",
            "\tfor(int i=3;i*i<MAX;i++) {",
            "\t\tif(spf[i]==i) {",
            "\t\t\tfor (int j=i*i;j<MAX;j+=i)",
            "\t\t\t\tif (spf[j]==j) spf[j] = i; ",
            "\t\t} ",
            "\t} ",
            "} ",
            "",
            "vector<int> getFactorization(int x)     // O(logn)",
            "{ ",
            "\tvector<int> ret;",
            "\twhile (x!=1) ",
            "\t{ ",
            "\t\tret.push_back(spf[x]);",
            "\t\tx=x/spf[x];",
            "\t} ",
            "\treturn ret;",
            "}",
        ]
    },
    "Continous Frequency": {
        "prefix": [
            "freq",
            "continuous",
        ],
        "body": [
            "vector<int> frequency(vector<int> V) {",
            "\tvector<int> freq;",
            "\tint prev=V[0];",
            "\tint count=1;",
            "\tfor(int i=1;i<V.size();i++) {",
            "\t\tif(V[i]==prev) count++;",
            "\t\telse {",
            "\t\t\tfreq.push_back(count);",
            "\t\t\tcount=1;",
            "\t\t}",
            "\t\t\tprev=V[i];",
            "\t}",
            "\tfreq.push_back(count);",
            "\treturn freq;",
            "}",
        ],
    }
}